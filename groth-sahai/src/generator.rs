//! Contains the CRS and the functionality a trusted party can use to generate it.
//!
//! The Common Reference String (CRS) for Groth-Sahai consists of a commitment keypair `(u, v)` and
//! the bilinear group generators `(g1, g2, gt)`.
//!
//! - As per [[GSW '10]](https://www.iacr.org/archive/pkc2010/60560179/60560179.pdf), the CRS
//!   should either be generated by a trusted party or through some other form of trusted
//!   computation as a binding key for a real system.
//! - The committment keys `u` and `v` should be computationally indistinguishable
//!   under the SXDH assumption as to whethere they were instantiated as a:
//!    1) Perfect soundness string (i.e. perfectly binding), or
//!    2) Composable witness-indistinguishability string (i.e. perfectly hiding)

use crate::data_structures::{Com1, Com2};

use ark_ec::{
    pairing::{Pairing, PairingOutput},
    CurveGroup,
};
use ark_ff::{UniformRand, Zero};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_std::{ops::Mul, rand::Rng};

/// An abstract trait for denoting how to generate a CRS
pub trait AbstractCrs<E: Pairing> {
    /// Generates the keys `u` for committing `G1` and `Fr` to
    /// [`B1`](crate::data_structures::B1) and `v` for committing `G2` and `Fr` to
    /// [`B2`](crate::data_structures::B2).
    fn generate_crs<R>(rng: &mut R) -> Self
    where
        R: Rng;
}

/// Contains the commitment keys and bilinear group generators
#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct CRS<E: Pairing> {
    pub u: Vec<Com1<E>>,
    pub v: Vec<Com2<E>>,
    pub g1_gen: E::G1Affine,
    pub g2_gen: E::G2Affine,
    pub gt_gen: PairingOutput<E>,

    /// G1 binding tag (public): u_{i,1} = a1 * u_{i,0}
    pub a1: E::ScalarField,
    /// G2 binding tag (public): v_{j,1} = a2 * v_{j,0}
    pub a2: E::ScalarField,
}

impl<E: Pairing> CRS<E> {
    // Returns intermediate "second" values that are used to construct un-blinded (i.e. binding) committment keys
    #[inline(always)]
    #[allow(unused_variables)]
    fn prepare_real_binding_key(
        g1_gen: E::G1,
        g2_gen: E::G2,
        q1: E::G1,
        t1: E::ScalarField,
        q2: E::G2,
        t2: E::ScalarField,
    ) -> (E::G1, E::G2) {
        // NOTE: v1 and v2 should be the only difference between a blinding and a hiding key
        let v1 = q1.mul(t1) - E::G1::zero();
        let v2 = q2.mul(t2) - E::G2::zero();
        (v1, v2)
    }

    // Returns intermediate "second" values that are used to construct blinded (i.e. hiding) committment keys
    #[inline(always)]
    #[allow(dead_code)]
    fn prepare_simulated_hinding_key(
        g1_gen: E::G1,
        g2_gen: E::G2,
        q1: E::G1,
        t1: E::ScalarField,
        q2: E::G2,
        t2: E::ScalarField,
    ) -> (E::G1, E::G2) {
        // NOTE: v1 and v2 should be the only difference between a blinding and a hiding key
        let v1 = q1.mul(t1) - g1_gen;
        let v2 = q2.mul(t2) - g2_gen;
        (v1, v2)
    }
}

impl<E: Pairing> AbstractCrs<E> for CRS<E> {
    fn generate_crs<R>(rng: &mut R) -> CRS<E>
    where
        R: Rng,
    {
        // Generators for G1 and G2
        let p1 = E::G1::rand(rng);
        let p2 = E::G2::rand(rng);

        // Scalar intermediate values
        let a1 = E::ScalarField::rand(rng);
        let a2 = E::ScalarField::rand(rng);
        let t1 = E::ScalarField::rand(rng);
        let t2 = E::ScalarField::rand(rng);

        // Projective intermediate values
        let q1 = p1.mul(a1);
        let q2 = p2.mul(a2);
        let u1 = p1.mul(t1);
        let u2 = p2.mul(t2);

        let (v1, v2) = Self::prepare_real_binding_key(p1, p2, q1, t1, q2, t2);

        // B1 commitment key for G1 and Fr
        let u11 = Com1::<E>(p1.into_affine(), q1.into_affine());
        let u12 = Com1::<E>(u1.into_affine(), v1.into_affine());

        // B2 commitment key for G2 and Fr
        let u21 = Com2::<E>(p2.into_affine(), q2.into_affine());
        let u22 = Com2::<E>(u2.into_affine(), v2.into_affine());

        CRS::<E> {
            u: vec![u11, u12],
            v: vec![u21, u22],
            g1_gen: p1.into_affine(),
            g2_gen: p2.into_affine(),
            gt_gen: E::pairing(p1.into_affine(), p2.into_affine()),
            a1,
            a2,
        }
    }
}

impl<E: Pairing> CRS<E> {
    /// Generate a CRS with per-slot independent rows for rank-decomposition PPE.
    ///
    /// This allocates 2*m rows for X-slots and 2*n rows for Y-slots, where each
    /// slot has independent randomizer and variable rows. This is required for
    /// offline PVUGC ARMER with rank-decomposition.
    ///
    /// # Arguments
    /// * `m` - Number of X-variable slots (G1 commitments)
    /// * `n` - Number of Y-variable slots (G2 commitments)
    ///
    /// # Example
    /// ```ignore
    /// let crs = CRS::<Bls12_381>::generate_crs_per_slot(&mut rng, 3, 2);
    /// assert_eq!(crs.num_x_slots(), 3);
    /// assert_eq!(crs.num_y_slots(), 2);
    /// assert_eq!(crs.u.len(), 6);  // 2 * 3
    /// assert_eq!(crs.v.len(), 4);  // 2 * 2
    /// ```
    pub fn generate_crs_per_slot<R: Rng>(rng: &mut R, m: usize, n: usize) -> Self {
        // Common generators (shared across all slots)
        let p1 = E::G1::rand(rng);
        let p2 = E::G2::rand(rng);
        let a1 = E::ScalarField::rand(rng);
        let a2 = E::ScalarField::rand(rng);

        let q1 = p1.mul(a1);
        let q2 = p2.mul(a2);

        // Generate per-slot rows for X (G1) - each slot gets 2 rows
        // Enforce simple linear relation u_{i,1} = a1 * u_{i,0} per slot
        let mut u = Vec::with_capacity(2 * m);
        for _slot_i in 0..m {
            let t_i = E::ScalarField::rand(rng);
            let u_i_0 = p1.mul(t_i);
            let (u_i_1, _) =
                Self::prepare_real_binding_key(p1, p2, q1, t_i, q2, E::ScalarField::zero());

            // Randomizer row for slot i: (p1, q1) where q1 = a1*p1
            u.push(Com1::<E>(p1.into_affine(), q1.into_affine()));
            // Variable row for slot i: (u_{i,0}, u_{i,1}) where u_{i,1} = a1*u_{i,0}
            u.push(Com1::<E>(u_i_0.into_affine(), u_i_1.into_affine()));
        }

        // Generate per-slot rows for Y (G2) - each slot gets 2 rows
        // Enforce simple linear relation v_{j,1} = a2 * v_{j,0} per slot
        let mut v = Vec::with_capacity(2 * n);
        for _slot_j in 0..n {
            let t_j = E::ScalarField::rand(rng);
            let v_j_0 = p2.mul(t_j);
            let (_, v_j_1) =
                Self::prepare_real_binding_key(p1, p2, q1, E::ScalarField::zero(), q2, t_j);

            // Randomizer row for slot j: (p2, q2) where q2 = a2*p2
            v.push(Com2::<E>(p2.into_affine(), q2.into_affine()));
            // Variable row for slot j: (v_{j,0}, v_{j,1}) where v_{j,1} = a2*v_{j,0}
            v.push(Com2::<E>(v_j_0.into_affine(), v_j_1.into_affine()));
        }

        CRS::<E> {
            u,
            v,
            g1_gen: p1.into_affine(),
            g2_gen: p2.into_affine(),
            gt_gen: E::pairing(p1.into_affine(), p2.into_affine()),
            a1,
            a2,
        }
    }

    /// Get the randomizer and variable rows for X slot i.
    ///
    /// Returns `(randomizer_row, variable_row)` where each is a `Com1` element.
    /// The randomizer row (index `2*i`) is used for blinding.
    /// The variable row (index `2*i+1`) is used for encoding the witness.
    ///
    /// # Panics
    /// Panics if the slot index is out of bounds.
    pub fn u_for_slot(&self, slot_i: usize) -> (&Com1<E>, &Com1<E>) {
        assert!(
            2 * slot_i + 1 < self.u.len(),
            "X slot index {} out of bounds (have {} slots)",
            slot_i,
            self.u.len() / 2
        );
        (&self.u[2 * slot_i], &self.u[2 * slot_i + 1])
    }

    /// Get the randomizer and variable rows for Y slot j.
    ///
    /// Returns `(randomizer_row, variable_row)` where each is a `Com2` element.
    /// The randomizer row (index `2*j`) is used for blinding.
    /// The variable row (index `2*j+1`) is used for encoding the witness.
    ///
    /// # Panics
    /// Panics if the slot index is out of bounds.
    pub fn v_for_slot(&self, slot_j: usize) -> (&Com2<E>, &Com2<E>) {
        assert!(
            2 * slot_j + 1 < self.v.len(),
            "Y slot index {} out of bounds (have {} slots)",
            slot_j,
            self.v.len() / 2
        );
        (&self.v[2 * slot_j], &self.v[2 * slot_j + 1])
    }

    /// Number of X-variable slots in this CRS.
    ///
    /// Each slot has 2 rows (randomizer and variable), so this returns `u.len() / 2`.
    pub fn num_x_slots(&self) -> usize {
        self.u.len() / 2
    }

    /// Number of Y-variable slots in this CRS.
    ///
    /// Each slot has 2 rows (randomizer and variable), so this returns `v.len() / 2`.
    pub fn num_y_slots(&self) -> usize {
        self.v.len() / 2
    }
}

#[cfg(test)]
mod tests {
    use ark_bls12_381::Bls12_381 as F;
    use ark_ec::{pairing::Pairing, AffineRepr, CurveGroup};
    use ark_ff::Zero;
    use ark_std::test_rng;

    use super::*;

    type G1Projective = <F as Pairing>::G1;
    type G1Affine = <F as Pairing>::G1Affine;
    type G2Projective = <F as Pairing>::G2;
    type G2Affine = <F as Pairing>::G2Affine;
    type GT = PairingOutput<F>;
    type Fr = <F as Pairing>::ScalarField;

    #[test]
    fn test_valid_generators() {
        let mut rng = test_rng();

        let crs = CRS::<F>::generate_crs(&mut rng);

        // Generator for GT is e(g1,g2)
        assert_eq!(crs.gt_gen, F::pairing(crs.g1_gen, crs.g2_gen));
        // Non-degeneracy of bilinear pairing will hold
        assert_ne!(crs.g1_gen, G1Affine::zero());
        assert_ne!(crs.g2_gen, G2Affine::zero());
        assert_ne!(crs.gt_gen, GT::zero());
    }

    #[allow(non_snake_case)]
    #[test]
    fn test_valid_binding_CRS() {
        std::env::set_var("DETERMINISTIC_TEST_RNG", "1");
        let mut rng = test_rng();
        let mut rng2 = test_rng();

        let crs = CRS::<F>::generate_crs(&mut rng);

        // Follow the same process as necessary to prepare a binding key
        let p1 = G1Projective::rand(&mut rng2);
        let p2 = G2Projective::rand(&mut rng2);
        let a1 = Fr::rand(&mut rng2);
        let a2 = Fr::rand(&mut rng2);
        let t1 = Fr::rand(&mut rng2);
        let t2 = Fr::rand(&mut rng2);
        let q1 = p1.mul(a1);
        let q2 = p2.mul(a2);
        let (v1, v2) = CRS::<F>::prepare_real_binding_key(p1, p2, q1, t1, q2, t2);

        // Generated commitment keys are non-trivial
        assert_ne!(crs.u[0], Com1::zero());
        assert_ne!(crs.u[1], Com1::zero());
        assert_ne!(crs.v[0], Com2::zero());
        assert_ne!(crs.v[1], Com2::zero());

        // The chosen keys are binding (i.e. not hiding)
        assert_ne!(crs.g1_gen, G1Affine::zero());
        assert_ne!(crs.g2_gen, G2Affine::zero());
        assert_eq!(crs.u[1].1, v1.into_affine());
        assert_eq!(crs.v[1].1, v2.into_affine());
    }

    #[test]
    #[allow(non_snake_case)]
    fn test_CRS_serde() {
        let mut rng = test_rng();
        let crs = CRS::<F>::generate_crs(&mut rng);

        let mut c_bytes = Vec::new();
        crs.serialize_compressed(&mut c_bytes).unwrap();
        let crs_deserialized = CRS::<F>::deserialize_compressed(&c_bytes[..]).unwrap();
        assert_eq!(crs.u, crs_deserialized.u);
        assert_eq!(crs.v, crs_deserialized.v);
        assert_eq!(crs.g1_gen, crs_deserialized.g1_gen);
        assert_eq!(crs.g2_gen, crs_deserialized.g2_gen);
        assert_eq!(crs.gt_gen, crs_deserialized.gt_gen);

        let mut u_bytes = Vec::new();
        crs.serialize_uncompressed(&mut u_bytes).unwrap();
        let crs_deserialized = CRS::<F>::deserialize_uncompressed(&u_bytes[..]).unwrap();
        assert_eq!(crs.u, crs_deserialized.u);
        assert_eq!(crs.v, crs_deserialized.v);
        assert_eq!(crs.g1_gen, crs_deserialized.g1_gen);
        assert_eq!(crs.g2_gen, crs_deserialized.g2_gen);
        assert_eq!(crs.gt_gen, crs_deserialized.gt_gen);
    }

    // === Phase 1: Per-Slot CRS Tests ===

    #[test]
    fn test_per_slot_crs_generation() {
        use ark_bls12_381::Bls12_381 as F;
        use ark_std::test_rng;

        let mut rng = test_rng();
        let m = 3; // X slots
        let n = 2; // Y slots
        let crs = CRS::<F>::generate_crs_per_slot(&mut rng, m, n);

        // Check slot counts
        assert_eq!(crs.num_x_slots(), m, "Should have {} X slots", m);
        assert_eq!(crs.num_y_slots(), n, "Should have {} Y slots", n);

        // Check raw vector lengths
        assert_eq!(
            crs.u.len(),
            2 * m,
            "Should have {} u rows (2 per slot)",
            2 * m
        );
        assert_eq!(
            crs.v.len(),
            2 * n,
            "Should have {} v rows (2 per slot)",
            2 * n
        );

        println!("Per-slot CRS generation: correct dimensions");
    }

    #[test]
    fn test_per_slot_crs_independence() {
        use ark_bls12_381::Bls12_381 as F;
        use ark_std::test_rng;

        let mut rng = test_rng();
        let crs = CRS::<F>::generate_crs_per_slot(&mut rng, 3, 2);

        // Get bases for different X slots
        let (_u0_rand, u0_var) = crs.u_for_slot(0);
        let (_u1_rand, u1_var) = crs.u_for_slot(1);
        let (_u2_rand, u2_var) = crs.u_for_slot(2);

        // Variable rows should differ (different t_i scalars)
        // Note: Randomizer rows use the same generator (p1, q1), but that's OK
        // What matters is the full 2D structure per slot
        assert_ne!(u0_var.0, u1_var.0, "Slot 0 and 1 var rows should differ");
        assert_ne!(u1_var.0, u2_var.0, "Slot 1 and 2 var rows should differ");
        assert_ne!(u0_var.0, u2_var.0, "Slot 0 and 2 var rows should differ");

        // Get bases for different Y slots
        let (_v0_rand, v0_var) = crs.v_for_slot(0);
        let (_v1_rand, v1_var) = crs.v_for_slot(1);

        assert_ne!(v0_var.0, v1_var.0, "Y slot 0 and 1 var rows should differ");

        println!("Per-slot CRS independence: variable rows are independent");
    }

    #[test]
    fn test_slot_accessor_methods() {
        use ark_bls12_381::Bls12_381 as F;
        use ark_std::test_rng;

        let mut rng = test_rng();
        let crs = CRS::<F>::generate_crs_per_slot(&mut rng, 2, 2);

        // Access X slots
        let (u0_rand, u0_var) = crs.u_for_slot(0);
        assert_eq!(u0_rand, &crs.u[0], "Slot 0 rand row should be at index 0");
        assert_eq!(u0_var, &crs.u[1], "Slot 0 var row should be at index 1");

        let (u1_rand, u1_var) = crs.u_for_slot(1);
        assert_eq!(u1_rand, &crs.u[2], "Slot 1 rand row should be at index 2");
        assert_eq!(u1_var, &crs.u[3], "Slot 1 var row should be at index 3");

        // Access Y slots
        let (v0_rand, v0_var) = crs.v_for_slot(0);
        assert_eq!(v0_rand, &crs.v[0], "Slot 0 rand row should be at index 0");
        assert_eq!(v0_var, &crs.v[1], "Slot 0 var row should be at index 1");

        let (v1_rand, v1_var) = crs.v_for_slot(1);
        assert_eq!(v1_rand, &crs.v[2], "Slot 1 rand row should be at index 2");
        assert_eq!(v1_var, &crs.v[3], "Slot 1 var row should be at index 3");

        println!("Slot accessor methods: correct indexing");
    }

    #[test]
    #[should_panic(expected = "X slot index 2 out of bounds")]
    fn test_slot_accessor_bounds_x() {
        use ark_bls12_381::Bls12_381 as F;
        use ark_std::test_rng;

        let mut rng = test_rng();
        let crs = CRS::<F>::generate_crs_per_slot(&mut rng, 2, 2);

        // This should panic - only slots 0 and 1 exist
        let _ = crs.u_for_slot(2);
    }

    #[test]
    #[should_panic(expected = "Y slot index 3 out of bounds")]
    fn test_slot_accessor_bounds_y() {
        use ark_bls12_381::Bls12_381 as F;
        use ark_std::test_rng;

        let mut rng = test_rng();
        let crs = CRS::<F>::generate_crs_per_slot(&mut rng, 2, 2);

        // This should panic - only slots 0 and 1 exist
        let _ = crs.v_for_slot(3);
    }

    #[test]
    fn test_backward_compatibility_global_crs() {
        use super::AbstractCrs;
        use ark_bls12_381::Bls12_381 as F;
        use ark_std::test_rng;

        let mut rng = test_rng();

        // Old style CRS (2 global rows)
        let crs_old = CRS::<F>::generate_crs(&mut rng);
        assert_eq!(crs_old.u.len(), 2, "Old CRS should have 2 u rows");
        assert_eq!(crs_old.v.len(), 2, "Old CRS should have 2 v rows");
        assert_eq!(crs_old.num_x_slots(), 1, "Old CRS interpreted as 1 X slot");
        assert_eq!(crs_old.num_y_slots(), 1, "Old CRS interpreted as 1 Y slot");

        // Can access slot 0
        let (_u_rand, _u_var) = crs_old.u_for_slot(0);
        let (_v_rand, _v_var) = crs_old.v_for_slot(0);

        println!("Backward compatibility: old CRS works with new accessors");
    }

    #[test]
    fn test_crs_binding_structure() {
        use ark_bls12_381::Bls12_381 as F;
        use ark_ec::{AffineRepr, CurveGroup};
        use ark_std::test_rng;

        let mut rng = test_rng();
        let m = 3; // X slots
        let n = 2; // Y slots
        let crs = CRS::<F>::generate_crs_per_slot(&mut rng, m, n);

        println!("\nCRS Binding Structure Test");
        println!("CRS binding tags: a1={}, a2={}", crs.a1, crs.a2);

        // Verify binding structure: u_{i,1} = a1 * u_{i,0} for all X slots
        for i in 0..m {
            let (u_rand, u_var) = crs.u_for_slot(i);

            // Check rand row: u_rand.1 == a1 * u_rand.0
            let expected_rand_1 = (u_rand.0.into_group() * crs.a1).into_affine();
            assert_eq!(
                u_rand.1, expected_rand_1,
                "X-slot {} rand row fails binding: u_rand.1 != a1 * u_rand.0",
                i
            );

            // Check var row: u_var.1 == a1 * u_var.0
            let expected_var_1 = (u_var.0.into_group() * crs.a1).into_affine();
            assert_eq!(
                u_var.1, expected_var_1,
                "X-slot {} var row fails binding: u_var.1 != a1 * u_var.0",
                i
            );
        }

        // Verify binding structure: v_{j,1} = a2 * v_{j,0} for all Y slots
        for j in 0..n {
            let (v_rand, v_var) = crs.v_for_slot(j);

            // Check rand row: v_rand.1 == a2 * v_rand.0
            let expected_rand_1 = (v_rand.0.into_group() * crs.a2).into_affine();
            assert_eq!(
                v_rand.1, expected_rand_1,
                "Y-slot {} rand row fails binding: v_rand.1 != a2 * v_rand.0",
                j
            );

            // Check var row: v_var.1 == a2 * v_var.0
            let expected_var_1 = (v_var.0.into_group() * crs.a2).into_affine();
            assert_eq!(
                v_var.1, expected_var_1,
                "Y-slot {} var row fails binding: v_var.1 != a2 * v_var.0",
                j
            );
        }

        println!("All slots satisfy binding structure:");
        println!("  - u_{{i,1}} = a1 * u_{{i,0}} for all {} X slots", m);
        println!("  - v_{{j,1}} = a2 * v_{{j,0}} for all {} Y slots", n);
    }
}
